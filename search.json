[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to read_pdz",
    "section": "",
    "text": "The X-Ray Fluorescence (XRF) data files that are produced by Bruker hand held XRF spectrometers are saved as .pdz files. Unfortunately these files are formatted as binary code.\nOver the last decades my lab, the Rijkserfgoedlaboratorium in Amsterdam, has used various types of Bruker hand held X-Ray Fluorescence (XRF) spectrometers. Measurement data is saved into .pdz files. Unfortunately these files use a proprietary non standard binary file format. Even worse, over time the .pdz file format has changed several times. This situation restricts access to the data to a limited number of researchers who can run the required Bruker software. Furthermore, it is likely that we will loose the ability to read the data at some point in the future.\nIn order to make optimal use of the XRF spectral data files in collaborative research projects now and to make sure that we can still read the data in the future we need to: 1) (at least partly) understand the file format, and 2) develop open software tools available to all researchers for reading and converting these data files.\nTo support open heritage science read_pdz package is currently being developed under the MIT open source software license. If you want to try yourselves you can install the latest version from pypi.org and study the documentation here.",
    "crumbs": [
      "Welcome to read_pdz"
    ]
  },
  {
    "objectID": "extracting-spectral-data.html",
    "href": "extracting-spectral-data.html",
    "title": "Extracting spectral data from pdz files",
    "section": "",
    "text": "This quote by internet pioneer Marleen Stikker is a fundamental truth that applies to software and technology as well as to data. In my lab there are many examples of data file formats that we can not easily read, share and use. This needs to change.\nBruker .pdz files are binary files that contain both XRF spectral data (i.e. photon counts) and metadata. Let’s ignore the gory details for now and show how to extract the spectral data and make a plot of the spectrum or spectra that are hidden in the file. To do so import the extract_spectra() function from the read_pdz package. The function requires a valid file path to a pdz file. It returns a pandas DataFrame that can be inspected in the notebook and is automatically saved as a .csv file in the same folder as the pdz file.\n\nfrom read_pdz import extract_spectrum\n\n\npdz_file = '/home/frank/Work/DATA/pdz-vgm-example-with-exports/demo.pdz'\nspectrum_df = extract_spectrum(pdz_file)\n\nSaving spectral data to: /home/frank/Work/DATA/pdz-vgm-example-with-exports/demo.pdz.csv\n\n\nThe spectral data in the DataFrame can now be processed further. If you quickly want to inspect the spectra you can use the .plot() method.\n\nax = spectrum_df.plot()\nax.set_title('my first pdz spectrum')\nax.set_xlabel('Energy [keV]')\nax.set_ylabel('Intensity [#counts]');",
    "crumbs": [
      "Extracting spectral data from pdz files"
    ]
  },
  {
    "objectID": "parsing-bytes.html",
    "href": "parsing-bytes.html",
    "title": "About parsing pdz files",
    "section": "",
    "text": "Bruker .pdz files are binary files that contain both XRF spectral data (i.e. photon counts) and metadata. There is no official description of the file format yet, so in order to decode the bytes we need to do some reverse engineering. This will get a rather complicated, so fasten your seat belts…\nTo get started we need to read the pdz file into memory as a numpy array of bytes using the file_to_bytes() function.\nfrom read_pdz import file_to_bytes\npdz_file = '/home/frank/Work/DATA/read-pdz-demodata/s0243V1962_XRF_28_White edge clothes underpainting (Al 38um filter).pdz'\npdz_bytes = file_to_bytes(pdz_file)\nlen(pdz_bytes)\n\n8690\nWe see that this pdz file contains 8690 bytes. Let’s take a look at the first 6 bytes…\nfirst_six_bytes = pdz_bytes[0:6]\nfirst_six_bytes\n\narray([b'\\x19', b'', b'\\x0e', b'', b'', b''], dtype='|S1')\nThe standard Python library for decoding bytes is struct. In order to decode a sequence of bytes you can use the struct.unpack() function. As a first argument you need to supply a so-called format string. This is essentially a recipe that explains which bytes belong together and how to interpret the byte values of each group.\nWe happen to know that the byte order in pdz files is Little-Endian. This is indicated with the '&lt;' character. Next thing we know is that the first two bytes belong together and represent a ‘short’ integer value. This is indicated with the character 'h'. The next group of four bytes represents an integer. This is indicated with the character 'i'. For more detail on format characters see: format-characters.\nArmed with our format string '&lt;hi' we are now ready to decode our first six bytes:\nimport struct\nstruct.unpack('&lt;hi', first_six_bytes)\n\n(25, 14)\nUnfortunately the standard struct.unpack() function is not sufficient to decode pdz files. The reason for this is that Bruker pdz files contain different types of variable byte length segments that require more advanced decoding. An example of such a contraption is a variable length character string. The first four bytes of such a segment contain an integer value that represents the number of two byte characters following that belong to that string. Parsing such a string is then a two-step process. First read the size n of the string, and then read 2n bytes that contain the actual string characters. Another example of a variable byte length construct is the division of a pdz file into blocks. Here again we need to read an integer value to decide how many following bytes belong the block. So far we have discovered three types of variable byte length constructs that are being used in pdz files: file blocks, strings and tables.\nAn essential a first step in parsing a pdz file is a separation into it’s consecutive file blocks. This can be done by applying the get_blocks() function to the pdz_bytes array.\nfrom read_pdz import get_blocks\nblock_list = get_blocks(pdz_bytes)\n\nDetecting block sequence...\nOk!\nLet’s take a look at our block_list variable. Note that for long arrays not all values are printed…\nblock_list\n\n[{'block_type': 25,\n  'block_size': 14,\n  'start': 0,\n  'stop': 20,\n  'file_size': 8690,\n  'bytes': array([b'\\x19', b'', b'\\x0e', b'', b'', b'', b'p', b'', b'd', b'', b'z',\n         b'', b'2', b'', b'5', b'', b'\\x01', b'', b'', b''], dtype='|S1')},\n {'block_type': 1,\n  'block_size': 228,\n  'start': 20,\n  'stop': 254,\n  'file_size': 8690,\n  'bytes': array([b'\\x01', b'', b'\\xe4', b'', b'', b'', b'\\x08', b'', b'', b'', b'9',\n         b'', b'0', b'', b'0', b'', b'F', b'', b'4', b'', b'9', b'', b'6',\n         b'', b'9', b'', b'\\x08', b'', b'', b'', b'S', b'', b'K', b'', b'5',\n         b'', b'-', b'', b'4', b'', b'9', b'', b'6', b'', b'9', b'', b'-',\n         b'-', b'-', b'A', b'}', b'', b'\\x06', b'', b'', b'', b'A', b'',\n         b'm', b'', b'p', b'', b't', b'', b'e', b'', b'k', b'', b'\\x04',\n         b'', b'', b'', b'R', b'', b'x', b'', b'B', b'', b'x', b'', b'\\x03',\n         b'\\x08', b'\\x07', b'', b'', b'', b'M', b'', b'o', b'', b'v', b'',\n         b'a', b'', b'b', b'', b'l', b'', b'e', b'', b'\\x08', b'', b'', b'',\n         b'\\x01', b'', b'\\t', b'', b'', b'', b'8', b'', b'.', b'', b'0',\n         b'', b'.', b'', b'0', b'', b'.', b'', b'4', b'', b'4', b'', b'6',\n         b'', b'\\x02', b'', b'\\x06', b'', b'', b'', b'2', b'', b'0', b'',\n         b'0', b'', b'.', b'', b'3', b'', b'9', b'', b'\\x03', b'', b'\\x04',\n         b'', b'', b'', b'6', b'', b'.', b'', b'0', b'', b'3', b'', b'\\x04',\n         b'', b'\\x04', b'', b'', b'', b'3', b'', b'.', b'', b'0', b'', b'3',\n         b'', b'\\x05', b'', b'\\x04', b'', b'', b'', b'9', b'', b'.', b'',\n         b'2', b'', b'F', b'', b'\\x06', b'', b'\\x06', b'', b'', b'', b'2',\n         b'', b'0', b'', b'0', b'', b'.', b'', b'3', b'', b'9', b'',\n         b'\\x07', b'', b'\\x04', b'', b'', b'', b'1', b'', b'.', b'', b'1',\n         b'', b'1', b'', b'\\x08', b'', b'\\x04', b'', b'', b'', b'1', b'',\n         b'.', b'', b'0', b'', b'1', b''], dtype='|S1')},\n {'block_type': 2,\n  'block_size': 92,\n  'start': 254,\n  'stop': 352,\n  'file_size': 8690,\n  'bytes': array([b'\\x02', b'', b'\\\\', b'', b'', b'', b'\\x01', b'', b'', b'',\n         b'\\xaa', b'4', b'|', b'', b'\\x16', b'\\xee', b'K', b'', b'', b'',\n         b'', b'', b'', b'', b'', b'', b'x', b'\\x94', b']', b'B', b'\\xe4',\n         b'%', b']', b'B', b'\\xd8', b'\\xa3', b'\\x86', b'A', b'\\xd3',\n         b'\\xcc', b'^', b'A', b'\\x8a', b'A', b'\\xc4', b'A', b'{', b'\\x8e',\n         b'\\xe1', b'B', b'\\x05', b'', b'', b'', b'A', b'', b'r', b'', b't',\n         b'', b'a', b'', b'x', b'', b'\\t', b'', b'', b'', b'8', b'', b'.',\n         b'', b'0', b'', b'.', b'', b'0', b'', b'.', b'', b'4', b'', b'4',\n         b'', b'6', b'', b'\\x04', b'', b'', b'', b't', b'', b'e', b'', b's',\n         b'', b't', b''], dtype='|S1')},\n {'block_type': 3,\n  'block_size': 8332,\n  'start': 352,\n  'stop': 8690,\n  'file_size': 8690,\n  'bytes': array([b'\\x03', b'', b'\\x8c', ..., b'', b'', b''], dtype='|S1')}]\nThe example pdz file here contains exactly four consecutive blocks of bytes. Within each block the first two bytes of contain a (short) integer value that indicates the type of block, while the second four bytes contain an integer value that describes the length of that block. The first two bytes of the first block contain an integer value 25. This indicates that the pdz format is 25. The next blocks are of type 1, 2 and 3. Block types 1 and 2 contain various instrument metadata, while block type 3 contains the actual spectral data. According to our local XRF guru Luc Megens a pdz file can contain multiple XRF spectra in separate type 3 blocks. Furthermore pdz files can contain type 4, 5 and 6 blocks. For now we will ignore these…\nTo enable the parsing of variable length strings and tables I created an extended format string syntax that besides standard struct format characters includes a capital 'S' and 'T' for strings and tables, and 'X' for skipping bytes. Both 'S' and 'X' can be prefixed with and integer multiplier that indicates how many strings and bytes need to be parsed. For example 3X will skip 3 bytes. If you need to skip an unknown amount of bytes at the end of an array you can put a wildcard *X multiplier at the end of the xformat string. These additional characters need to be separated from standard struct format strings with dashes '-'. Another important extension of the syntax is 'Z'. This indicates at which position the actual spectral data of 2048 photon counts should be read.\nTo read the information that is hidden in the bytes array of a block we can now apply the function multiparse(). This function needs as required arguments an extended syntax format string xformat and an array of bytes arr. The xformat string functions as a recipe to decode the bytes array. The xformat strings for decoding block types 25, 1, 2 and 3 are stored in the PDZ_25_STRUCTURE_DICT dictionary. Also included for each block is a param_keys list with our interpretation of the parsed values based on a comparison with other exports from Bruker software. In cases where we could not find out we put question marks.\nfrom read_pdz import multiparse, PDZ_25_STRUCTURE_DICT\nBefore parsing the bytes from the file blocks it is informative to take look at the PDZ_25_STRUCTURE_DICT dictionary. This provides a complete specification of the pdz file format.\nWith this pdz file format specification we can decode the four blocks in the pdz file one by one. Let’s parse the bytes of first block (type 25) of the pdz file with the corresponding xformat string and param_keys list.\nxformat = PDZ_25_STRUCTURE_DICT[25]['xformat']\nparam_keys = PDZ_25_STRUCTURE_DICT[25]['param_keys']\nxformat, param_keys\n\n('hi-10X-i', ['pdz_type', 'block_size', 'FileFormatString?', '??'])\nThe recipe for reading this first file block is quite short: h: read a two byte integer, i: read a four byte integer, 10X: skip ten bytes, i: read another four byte integer.\nb0 = block_list[0]['bytes']\nmultiparse(xformat, b0);\n\n\n\n\n\n\n\n\nvalues\n\n\n\n\n0\n25\n\n\n1\n14\n\n\n2\nb'pdz25'\n\n\n3\n1\nThe multiparse() function can be given an optional third argument that is a list with the interpretation of each value.\nmultiparse(xformat, b0, param_keys=param_keys);\n\n\n\n\n\n\n\n\nvalues\nparam_keys\n\n\n\n\n0\n25\npdz_type\n\n\n1\n14\nblock_size\n\n\n2\nb'pdz25'\nFileFormatString?\n\n\n3\n1\n??\nNext we read the second block…\nb1 = block_list[1]['bytes']\nxformat = PDZ_25_STRUCTURE_DICT[1]['xformat']\nparam_keys = PDZ_25_STRUCTURE_DICT[1]['param_keys'] \nxformat\n\n'hi-2S-6s-2S-h-S-T'\nmultiparse(xformat, b1, param_keys=param_keys);\n\n\n\n\n\n\n\n\nvalues\nparam_keys\n\n\n\n\n0\n1\nblock_type\n\n\n1\n228\nblock_size\n\n\n2\n900F4969\n??\n\n\n3\nSK5-4969\nSerialString\n\n\n4\nb'---A}\\x00'\n??\n\n\n5\nAmptek\n??\n\n\n6\nRxBx\n??\n\n\n7\n2051\n??\n\n\n8\nMovable\n??\n\n\n9\n[#1, 8.0.0.446]\n??\n\n\n10\n[#2, 200.39]\n??\n\n\n11\n[#3, 6.03]\n??\n\n\n12\n[#4, 3.03]\n??\n\n\n13\n[#5, 9.2F]\n??\n\n\n14\n[#6, 200.39]\n??\n\n\n15\n[#7, 1.11]\n??\n\n\n16\n[#8, 1.01]\n??\nThis file block (type 1) contains values that seem to indicate serial numbers and probably software versions. Not sure how useful this information is for us. Let’s read the next block.\nb2 = block_list[2]['bytes']\nxformat = PDZ_25_STRUCTURE_DICT[2]['xformat']\nparam_keys = PDZ_25_STRUCTURE_DICT[2]['param_keys'] \nxformat\n\n'hi3i8f-*X'\nmultiparse(xformat, b2, param_keys=param_keys);\n\n\n\n\n\n\n\n\nvalues\nparam_keys\n\n\n\n\n0\n2\nblock_type\n\n\n1\n92\nblock_size\n\n\n2\n1\n??\n\n\n3\n8139946\nRawCounts\n\n\n4\n4976150\nValidCounts\n\n\n5\n0.0\n??\n\n\n6\n0.0\n??\n\n\n7\n55.394989\n??\n\n\n8\n55.287003\nActiveTimeInSeconds\n\n\n9\n16.830002\nDeadTimeInSeconds\n\n\n10\n13.925006\nResetTimeInSeconds\n\n\n11\n24.532001\nLiveTimeInSeconds\n\n\n12\n112.778282\nTotalElapsedTimeInSeconds\n\n\n13\nb'\\x05Artax\\t8.0.0.446\\x04test'\n??\nFile block 2 primarily contains instrumental data about measurement times and detector counts.\nFinally we parse file block type 3. This block contains two parts. The first part contains spectral parameters, while the second part contains the actual spectral data (i.e. photon counts consisting of 2048 four byte integers.\nb3 = block_list[3]['bytes']\nb3_part1 = b3[0:-2054] # spectral parameters\nb3_part2 = b3[-2054:] # counts \n\nxformat = PDZ_25_STRUCTURE_DICT[3]['xformat']\nparam_keys = PDZ_25_STRUCTURE_DICT[3]['param_keys'] \nxformat\n\n'hi-3i9f7hfhfhfhf8hfhi-*Z'\nvalues,  arr = multiparse(xformat, b3, param_keys=param_keys)\n\n\n\n\n\n\n\n\nvalues\nparam_keys\n\n\n\n\n0\n3\nblock_type\n\n\n1\n8332\nblock_size\n\n\n2\n0\n??\n\n\n3\n8139946\nRawCounts\n\n\n4\n4976150\nValidCounts\n\n\n5\n0.0\n??\n\n\n6\n0.0\n??\n\n\n7\n55.394989\n??\n\n\n8\n55.287003\nActiveTimeInSeconds\n\n\n9\n16.830002\nDeadTimeInSeconds\n\n\n10\n13.925006\nResetTimeInSeconds\n\n\n11\n24.532001\nLiveTimeInSeconds\n\n\n12\n40.0\nXrayVoltageInkV\n\n\n13\n8.0\nXrayFilamentCurrentInMicroAmps\n\n\n14\n13\nFilter1ElementAtomicNum\n\n\n15\n38\nFilter1Thickness\n\n\n16\n0\nFilter2ElementAtomicNum\n\n\n17\n0\nFilter2Thickness\n\n\n18\n0\nFilter3ElementAtomicNum\n\n\n19\n0\nFilter3Thickness\n\n\n20\n5\n??\n\n\n21\n37.5\nDetectorTempInC\n\n\n22\n0\n??\n\n\n23\n0.0\n??\n\n\n24\n0\n??\n\n\n25\n20.0\neVPerChannel\n\n\n26\n2\n??\n\n\n27\n2.356571\neVStart\n\n\n28\n2022\nYear\n\n\n29\n8\nMonth\n\n\n30\n2\nAM/PM code?\n\n\n31\n23\nDay\n\n\n32\n11\nHour\n\n\n33\n54\nMinutes\n\n\n34\n32\nSeconds\n\n\n35\n320\n??\n\n\n36\n1017.0\nNosePressureInMilliBars\n\n\n37\n2048\nNumberOfChannels\n\n\n38\n38\nNoseTemperatureInC\n\n\n39\n[b'\\x0cRoHS 50 Hi-Z\\x01']\n??\n\n\n40\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, ...\nIntensity_2048_channels\nWe can see in the table above that the last row contains an array of 2048 integers with photon counts. This array can accessed by indexing the last element of the returned values list like so:\nvalues[-1]\n\narray([0, 0, 0, ..., 2, 2, 3])\nThe energy calibration for the individual 2048 detector channels is not stored in the pdz file but can be calculated from two spectral parameters: eVPerChannel and eVStart. This is done automatically for you in the extract_spectra() function as explained in the previous section. If you want to save the spectral data to a .csv file then set the option to_csv=True.\nfrom read_pdz import extract_spectrum\ndf = extract_spectrum(pdz_file, to_csv=True)\n\nSaving spectral data to: /home/frank/Work/DATA/read-pdz-demodata/s0243V1962_XRF_28_White edge clothes underpainting (Al 38um filter).pdz.csv\nax = df.plot()\nax.set_xlabel('Energy (keV)')\nax.set_ylabel('Intensity (counts');",
    "crumbs": [
      "About parsing pdz files"
    ]
  },
  {
    "objectID": "parsing-bytes.html#functions",
    "href": "parsing-bytes.html#functions",
    "title": "About parsing pdz files",
    "section": "FUNCTIONS",
    "text": "FUNCTIONS\n\nsource\n\nget_blocktypes\n\n get_blocktypes (block_list)\n\nExtract block_types list from block_list.\n\nsource\n\n\nget_blocks\n\n get_blocks (pdz_bytes, verbose=True)\n\nParse pdz_byte_array into consequtive blocks.\n\nsource\n\n\nget_block_at\n\n get_block_at (pdz_arr, start)\n\n*Read first data block from bytes array pdz_arr from index position start.\nAssumes that first 4 bytes are (block type and size)\nReturns: block_dict, block*\n\nsource\n\n\nread_counts\n\n read_counts (xformat, arr, verbose=True)\n\nExtract counts.\n\nsource\n\n\nread_table\n\n read_table (xformat, arr, verbose=True)\n\nExtract numbered table\n\nsource\n\n\nskip_bytes\n\n skip_bytes (xformat, arr, verbose=True)\n\n*Skip a number of bytes as specified in xformat string.\nIf multiplier is * then skip all.*\n\nsource\n\n\nread_strings\n\n read_strings (xformat, arr, verbose=True)\n\nParse n variable length character strings preceded by a length integer.\n\nsource\n\n\nparse\n\n parse (format, arr, verbose=True)\n\n*Parse first bytes from bytes array arr into human readable text according to format string.\nSee struct library for format string specification. For example, ‘&lt;ff’ would result the first 8 bytes to be converted into two Little-Endian floats.\nReturns: parsed list and remaining bytes array of tail_arr unprocessed values.*\n\nsource\n\n\nfile_to_bytes\n\n file_to_bytes (pdz_file)\n\n*Read all bytes from filepath pdz_file into a byte array.\nReturns: pdz_arr (numpy array of bytes)*\n\nsource\n\n\nprefix\n\n prefix (format)\n\nPrefix little endian byte order (&lt;) to struct type format string if missing.\n\nsource\n\n\nmultiparse\n\n multiparse (xformat, arr, param_keys=None, verbose=True)\n\nParse segments in extendend format string xformat e.g. ‘&lt;i5f-2S-T-3S-S-f’",
    "crumbs": [
      "About parsing pdz files"
    ]
  },
  {
    "objectID": "pdz-archeology.html",
    "href": "pdz-archeology.html",
    "title": "Pdz archaeology",
    "section": "",
    "text": "If you did not develop a headache in the previous section, then this section is for you! We need to resolve one more problem of reading ancient pdz file formats.\nAs explained in the previous section, the currently prevalent pdz file format version pdz25 contains multiple blocks of different types and variable size. The first two bytes of a pdz25 file decode as 25. This is not true for old ‘legacy format’ pdz files. In earlier days pdz files were formatted as one single block of data. Legacy files always start with two bytes with hexadecimal code \\x01\\x01. I call this format pdz11. The exact structure of these legacy files is not fixed, because some instrument detectors are equipped with 1024 channels, while other types contain 2048 channels. To complicate matters further the last part of pdz files can vary in length.\nTo check a pdz file type import the check_pdz_type() function and provide a valid file path to a pdz file. Listing pdz files is easily done with the standard library function glob('*.pdz').\nfrom read_pdz import check_pdz_type\nfrom glob import glob\nimport os\nLet’s check the pdz format for all demo data pdz files.\nos.chdir('/home/frank/Work/DATA/read-pdz-demodata/')  \npdz_files = sorted(glob('*.pdz'))\n\nprint('Checking pdz file format versions: \\n ')\nfor i, f in enumerate(pdz_files): \n    pdz_type = check_pdz_type(f)\n    print(f\"[{i}] {f}\\n    --&gt; format: '{pdz_type}'\\n\")\n\nChecking pdz file format versions: \n \n[0] 00066-Spectrum Only.pdz\n    --&gt; format: 'pdz25'\n\n[1] 00067-Spectrum Only.pdz\n    --&gt; format: 'pdz25'\n\n[2] 00068-Alloys 2.pdz\n    --&gt; format: 'pdz25'\n\n[3] 00069-Alloys 2.pdz\n    --&gt; format: 'pdz25'\n\n[4] 00081-Precious Metals 2.pdz\n    --&gt; format: 'pdz25'\n\n[5] 00085-Mudrock Dual.pdz\n    --&gt; format: 'pdz25'\n\n[6] 00086-Mudrock Dual.pdz\n    --&gt; format: 'pdz25'\n\n[7] 00181-Restricted Materials.pdz\n    --&gt; format: 'pdz25'\n\n[8] 00182-Restricted Materials.pdz\n    --&gt; format: 'pdz25'\n\n[9] 1-sky sample spot.pdz\n    --&gt; format: 'pdz11_1024_channels'\n\n[10] 2-sky left of left tree.pdz\n    --&gt; format: 'pdz11_1024_channels'\n\n[11] 3-brown left edge sample spot.pdz\n    --&gt; format: 'pdz11_1024_channels'\n\n[12] 59.pdz\n    --&gt; format: 'pdz11_2048_channels'\n\n[13] A1_a.pdz\n    --&gt; format: 'pdz11_2048_channels'\n\n[14] A7_a.pdz\n    --&gt; format: 'pdz11_2048_channels'\n\n[15] ANALYZE_EMP-10.pdz\n    --&gt; format: 'pdz11_2048_channels'\n\n[16] ANALYZE_EMP-11.pdz\n    --&gt; format: 'pdz11_2048_channels'\n\n[17] ANALYZE_EMP-12.pdz\n    --&gt; format: 'pdz11_2048_channels'\n\n[18] AffectionsGift1854_13218.pdz\n    --&gt; format: 'pdz25'\n\n[19] B11_a.pdz\n    --&gt; format: 'pdz11_2048_channels'\n\n[20] B5_a.pdz\n    --&gt; format: 'pdz11_2048_channels'\n\n[21] s0243V1962_XRF_28_White edge clothes underpainting (Al 38um filter).pdz\n    --&gt; format: 'pdz25'\n\n[22] with-three-images.pdz\n    --&gt; format: 'pdz25'\nLet’s now see how to parse a pdz11 file. To do so we need to import the multiparse() function and extended format strings for pdz11 files.\nfrom read_pdz import multiparse, file_to_bytes, PDZ11_STRUCT_DICT\nLet’s take a closer look at the structure of PDZ11 files.\nGiven the slightly different xformat strings for the two types of pdz11 legacy files we can now check if we can also parse these files correctly.\nCode\nn = 13  \npdz_file = pdz_files[n]\npdz_type = check_pdz_type(pdz_file) \narr = file_to_bytes(pdz_file)\n\nxformat = PDZ11_STRUCT_DICT[pdz_type]['xformat']\nparam_keys = PDZ11_STRUCT_DICT[pdz_type]['param_keys']\nprint(f\"file: '{pdz_file}'\\n--&gt; pdz type: '{pdz_type}'\\n--&gt; xformat string: '{xformat}'\")\n\n\nfile: 'A1_a.pdz'\n--&gt; pdz type: 'pdz11_2048_channels'\n--&gt; xformat string: '2X-i-h-34X-2d-86X-2i-10X-2f-188X-Z-*X'\nparsed, tail = multiparse(xformat, arr, param_keys=param_keys)\n\n\n\n\n\n\n\n\nvalues\nparam_keys\n\n\n\n\n0\nb'\\x01\\x01'\npdz-version\n\n\n1\n23\n??\n\n\n2\n2048\nNumberOfChannels\n\n\n3\nb'\\xc8\\xe6\\xc8\\xca\\xd6\\xd8\\x02\\x01?\\x02\\x01\\x04'\n??\n\n\n4\n0.0\n??\n\n\n5\n20.085341\neVPerChannel\n\n\n6\nb'\\xa8\\x91@\\x10\\x9d@\\xe0j@n@\\xf4\\x01\\x8c\\x02'\n??\n\n\n7\n132513792\nRawCounts\n\n\n8\n65538\nValidCounts\n\n\n9\nb'\\x0e\\t\\x11\\x07\\xde\\x02'\n??\n\n\n10\n35.0\nXrayVoltageInkV\n\n\n11\n7.0\nXrayFilamentCurrentInMicroAmps\n\n\n12\nb'\\x9d\\xcf\\xc8\\xfe\\x02\\xff\\xff\\n\\x18\\x80\\x10\\x...\n??\n\n\n13\n[781, 653, 461, 304, 146, 57, 27, 9, 2, 1, 0, ...\nIntensity (2048 channels)\n\n\n14\nb''\n??\nCode\nn = 11\npdz_file = pdz_files[n]\npdz_type = check_pdz_type(pdz_file) \narr = file_to_bytes(pdz_file)\n\nxformat = PDZ11_STRUCT_DICT[pdz_type]['xformat']\nparam_keys = PDZ11_STRUCT_DICT[pdz_type]['param_keys']\nprint(f\"file: '{pdz_file}'\\n--&gt; pdz type: '{pdz_type}'\\n--&gt; xformat string: '{xformat}'\")\n\n\nfile: '3-brown left edge sample spot.pdz'\n--&gt; pdz type: 'pdz11_1024_channels'\n--&gt; xformat string: '2X-i-h-34X-2d-86X-2i-10X-2f-24X-z-*X'\nparsed, tail = multiparse(xformat, arr, param_keys=param_keys)\n\n\n\n\n\n\n\n\nvalues\nparam_keys\n\n\n\n\n0\nb'\\x01\\x01'\npdz-version\n\n\n1\n20\n??\n\n\n2\n1024\nNumberOfChannels\n\n\n3\nb'\\xc8\\xe6\\xc8\\xca\\xd6\\xd8\\x02\\x01?\\x02\\xa6\\xf...\n??\n\n\n4\n60.76\n??\n\n\n5\n40.0\neVPerChannel\n\n\n6\nb'7\\xd4@\\xf9\\xd5@\\xe0j@n@\\xf0?-C\\x1c\\xeb\\xe26\\...\n??\n\n\n7\n1001652224\nRawCounts\n\n\n8\n519897088\nValidCounts\n\n\n9\nb'\\xc4w\\r0Y\\x07'\n??\n\n\n10\n40.0\nXrayVoltageInkV\n\n\n11\n2.2\nXrayFilamentCurrentInMicroAmps\n\n\n12\nb'\\xb9\\xa5\\x01\\x10\\xfe\\xffpmidefau'\n??\n\n\n13\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...\nIntensity (1024 channels)\n\n\n14\nb'\\x01\\x02\\x01\\x01\\x01\\x01\\x02\\x01\\x01\\x01\\x01...\n??\nAlthough legacy pdz11 file formats contain many bytes that we can not yet read, at least we can now extract the spectral data! I will show you here how to create a plot with spectra for all variants of pdz files in our pdz zoo. We need to import extract_spectrum() and matplotlib.pyplot to create our plot.\nfrom read_pdz import extract_spectrum\nimport matplotlib.pyplot as plt\ndf_list = [extract_spectrum(pf, to_csv=False, verbose=False) for pf in pdz_files]\nCode\nfig, ax = plt.subplots(figsize=[7, 7])\n\nfor df in df_list: \n    df.plot(ax=ax);\n\nax.legend(bbox_to_anchor=(1.04, 1), loc=\"upper left\")\nax.set_xlabel('Energy [keV]')\nax.set_ylabel('Intensity [#counts]');",
    "crumbs": [
      "Pdz archaeology"
    ]
  },
  {
    "objectID": "pdz-archeology.html#functions",
    "href": "pdz-archeology.html#functions",
    "title": "Pdz archaeology",
    "section": "FUNCTIONS",
    "text": "FUNCTIONS\n\nsource\n\nextract_spectrum\n\n extract_spectrum (pdz_file, to_csv=True, verbose=True)\n\n*Direct extraction of spectral data from pdz_file.\nShould now work for both pdz25 and both pdz11 file formats.*\n\nsource\n\n\ncheck_pdz_type\n\n check_pdz_type (pdz_file, verbose=True)\n\nRead first two bytes and for legacy pdz files number of detector channels to check pdz file type.",
    "crumbs": [
      "Pdz archaeology"
    ]
  },
  {
    "objectID": "extracting-image-data.html",
    "href": "extracting-image-data.html",
    "title": "Extracting image data from pdz files",
    "section": "",
    "text": "The newest Bruker Tracer XRF spectrometers are equipped with a simple RGB camera that can be used to record the location of the spectral measurement. These RGB images are then encoded as jpg binary data that are stored within a single specific block (type 137) in the pdz file. If a pdz file actually contains one or more sets of image data you can use the extract_jpg() function to get them out.\nfrom read_pdz import extract_jpg\npdz_file = '/home/frank/Work/DATA/read-pdz-demodata/00081-Precious Metals 2.pdz' # contains jpg image \nims = extract_jpg(pdz_file, save_file=True)\n\nSaving image file: '/home/frank/Work/DATA/read-pdz-demodata/00081-Precious Metals 2-0.jpg'\nLet’s take a look at the image. Can anyone tell what we see here?\nCode\nimport matplotlib.pyplot as plt\nCode\nfig, ax = plt.subplots()\nax.imshow(ims[0]);\nSome pdz files contain multiple images. Let’s see how they look like.\npdz_file = '/home/frank/Work/DATA/read-pdz-demodata/with-three-images.pdz' \nims = extract_jpg(pdz_file, save_file=True)\n\nSaving image file: '/home/frank/Work/DATA/read-pdz-demodata/with-three-images-0.jpg'\nSaving image file: '/home/frank/Work/DATA/read-pdz-demodata/with-three-images-1.jpg'\nSaving image file: '/home/frank/Work/DATA/read-pdz-demodata/with-three-images-2.jpg'\nCode\nimport matplotlib.pyplot as plt\nCode\nfig, axs = plt.subplots(ncols=3, figsize=[8, 3], squeeze=True)\n\nfor im, ax in zip(ims, axs): \n    ax.imshow(im)",
    "crumbs": [
      "Extracting image data from pdz files"
    ]
  },
  {
    "objectID": "extracting-image-data.html#functions",
    "href": "extracting-image-data.html#functions",
    "title": "Extracting image data from pdz files",
    "section": "FUNCTIONS",
    "text": "FUNCTIONS\n\nsource\n\nextract_jpg\n\n extract_jpg (pdz_file, BLOCKTYPE=137, save_file=False)\n\n*Extract and save jpg images from pdz_file.\nReturns a list of jpg images where ims = [ im0, im1, … ].*",
    "crumbs": [
      "Extracting image data from pdz files"
    ]
  },
  {
    "objectID": "getting-started.html",
    "href": "getting-started.html",
    "title": "Getting started with Python",
    "section": "",
    "text": "In order to use the read-pdz Python package, you need to be able to install Python packages and run Python code in Jupyter notebooks on your computer. The easiest way to get started with Jupyter notebooks is by downloading and installing the JupyterLab Desktop (JLD) installer for your operating system from the official github repository.\n\n\n\n\n\n\n\nNote\n\n\n\nThe first time you start JupyterLab Desktop you additionally need to install the default Python environment from the start menu.\n\n\nFinally you can install or update (with the -U option) the read-pdz package from the Python Package index pypi.org by executing this command from a code cell in a Jupyter notebook:\n%pip install -U read-pdz \nFor more information about JupyterLab Desktop see the JLD user guide.\nThat is it! You now are ready to open up your pdz files!",
    "crumbs": [
      "Getting started with Python"
    ]
  }
]